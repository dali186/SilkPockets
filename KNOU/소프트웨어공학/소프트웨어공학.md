# 소프트웨어공학
## Contents
+ [#1 소프트웨어 공학 개요](#소프트웨어-공학-개요)
+ [#2 소프트웨어 프로세스](#소프트웨어-프로세스)

### 소프트웨어 공학 개요
+ 기능에 따른 분류
  + 시스템 소프트웨어
    + 컴퓨터를 동작 시키기 위한 목적의 소프트웨어 (운영체제, 장치 드라이버, 컴파일러, DBMS...)
  + 응용 소프트웨어
    + 사용자의 실제 업무를 수행하는 소프트웨어 (웹 브라우저, 사무용/게임용 SW...)

+ 사용자에 따른 분류
  + 일반(generic) 소프트웨어
    + 불특정 다수를 대상으로 설계되는 패키지 소프트웨어
    + 요구사항이 일반적이고 안정적, 상용 제품으로 판매될 수 있음
    + DB관련 제품, 사무용 패키지, 운영체제...
  + 맞춤형(cutom) 소프트웨어
    + 특정 고객을 위해 주문 제작됨
    + 응용 도메인, 사용환경, 요구사항이 특별함
    + 프로세스 제어, 교통 관제, 병원 관리 시스템...

##### 소프트웨어의 성질
+ 물질적인 성질이 없음
+ 컴포넌트들의 조립을 통해 만들기 어려움
+ 설계 과정의 품질 보증 활동이 중요
+ 개발 비용의 대부분은 노동력에 투입
+ 상대적으로 변경이 용이 (소프트웨어의 유연성 또는 순응성)
+ 소프트웨어는 마모되지 않음
  + 욕조 곡선(bathtub curve)
    + 하드웨어는 초기에서 안정기까지 고장률이 낮아지다가 마모시기가 오면 다시 고장률이 상승
    + 반면에 소프트웨어는 시간이 지날수록 고장률이 낮아짐
      + 물론 소프트웨어도 시간이 지나면서 쓸모없어지거나 품질이 저하됨
+ 소프트웨어 유지보수 작업은 설계의 변경을 요구함

##### 소프트웨어 응용 분야
+ 시스템 소프트웨어
+ 실시간 소프트웨어
+ 내장형 소프트웨어 : 주로 시스템을 제어하는데 사용
+ 비즈니스 소프트웨어 : 사업 업무를 처리
+ 개인용 소프트웨어
+ 인공지능 소프트웨어
+ 웹 기반 소프트웨어
+ 공학용/과학용 소프트웨어

##### 소프트웨어 위기
+ 1968 NATO 소프트웨어 공학 컨퍼런스
  + 이 시기에는 H/W의 발전속도(요구의 다양화, 복잡화)가 S/W보다 빨랐음
    + 소프트웨어의 기술 발전이 더딤을 일컫는 용어
  + 소프트웨어 공학이라는 학문 분야의 등장 배경이 됨

###### 사례
+ 개발 일정의 지연
+ 초과 비용의 발생
+ 제품 신뢰도의 결여
+ 명세를 충족하지 못하는 제품
+ 유지보수의 어려움

###### 원인
+ 소프트웨어 엔지니어의 부족
+ 경영층의 인식 부족
+ 방법론과 도구의 부재, 개발 생산성의 저하
+ 소프트웨어 자체의 복잡성 증가

##### 소프트웨어 공학의 유래
+ **공학**이란 문제 해결을 위한 **결과물을 생산**하기 위해 지식이나 경험의 적용을 연구하는 분야

##### 소프트웨어 공학의 정의
+ NATO 컨퍼런스, 바우어 교수
  + 신뢰성, 요구기능 효율적으로 수행하는 SW를 경제적으로 생산하기 위함
+ IEEE 소프트웨어 공학 표준 용어집
  + 개발/운영/유지보수에 체계적이고 제어가능하며 정량화된 접근 방법을 적용

##### 소프트웨어 개발 시 고려 사항
+ 소프트웨어 개발이 단순한 코드의 생성이 아님
+ 개발 프로세스와 프로젝트 관리가 중요함
+ 비용을 줄이고 제품의 품질을 높이기 위한 방법
  + *문서화*와 *프로젝트 관리*가 중요함
  + *초기 요구사항 명세화* 작업에 노력을 기울여야 함
  + *변경*이나 *재사용*을 염두에 둔 작업이 필요함

##### 소프트웨어 공학 환경
+ 소프트웨어 공학의 대상은 중규모 이상의 중요한 소프트웨어
+ 다양한 해결 방법들을 통합적 (=환경)으로 다루어야함
+ 환경의 계층
  + 도구
  + 방법론
  + 방법과 기술
  + 소프트웨어 공학 원리

##### 소프트웨어 공학 환경의 구성
+ 소프트웨어 공학 원리
  + 일반적이고 추상적인 설명
+ 방법과 기술
  + 행위를 통제하는 체계적이고 일반적인 가이드라인
+ 방법론 
  + 방법과 기술들의 집합
  + 프로세스(what)와 방법(how)를 함께 기술

##### 소프트웨어 프로세스 모델
+ 소프트웨어 생산과 진화 과정을 추상화하여 요약 표현한 것(생명주기 모델)
+ 시스템 개념화 - 요구사항 정의 - 설계 - 구현 까지의 전이 과정을 표현
+ 좋은 프로세스 모델
  + 전이 과정에서 문제 최소화
  + 공통 개발 프레임워크를 제공하여 생산성 향상
  + 개발자 간 공통의 문화와 공통의 기술을 제공

##### 외부 품질과 내부 품질
+ 외부 품질
  + 사용자가 인지할 수 있는 품질 요소
  + 사용성, 속도, 신뢰도
+ 내부 품질
  + 개발자가 인지할 수 있는 품질 요소
  + 잘 작성된 요구사항이나 설계 문서

##### 소프트웨어 신뢰도
+ 정확한 결과 제공
+ 오류 발생이 적고 치명적이지 않으며 발생해도 무난히 복구(강건함)
+ 신뢰도를 결정하는 척도는 다 다름
+ 위에 언급한 SW임에도 불구하고 욕조 곡선과 유사한 형태를 가지는 경우도 있음

##### 소프트웨어 판단 기준
+ 신뢰성
  + 고장이 얼마나 덜 나는가
+ 정확성
  + 요구사항을 얼마나 만족시키는가
+ 성능
  + 얼마나 빠르게 처리하는가
+ 사용성
  + 본래 목적을 효율성있게 사용하는가
+ 상호운영성
  + 다른 시스템과 공존하며 협력할 수 있는가
+ 유지보수성
  + 변경이 얼마나 용이한가
+ 이식성
  + 다른 환경에서도 동작할 수 있는가
+ 검사성
  + 좋은 소프트웨어의 속성을 갖추었는지 검사할 수 있는가
+ 추적성
  + 이해관계자(stakeholder), 요구사항, 설계문서, 소스코드 간의 관계를 추적할 수 있는가

### 소프트웨어 프로세스
+ 소프트웨어 프로세스 
  + 소프트웨어 시스템을 개발하거나 유지보수할 목적으로 수행되는 활동 또는 절차
  + 프로세스 모델을 보유하여 공통의 개발 문화와 공통의 기술을 제공해야 함
    + 전체 프로세스의 이해
    + 구조화된 방법 적용
    + 자원 사용 사전 계획
    + 자원 사용 통제
    + 개발 과정을 추적하고 관리


##### 프로세스 활동
+ 소프트웨어 명세 : 소프트웨어의 기능과 운영상 제약 조건을 정함
+ 소프트웨어 개발 : 소프트웨어를 설계하고 프로그래밍 함
+ 소프트웨어 검증 : 고객이 원하는 것을 수행하는지 검사함
+ 소프트웨어 진화 : 소프트웨어를 변경
  + 일반 소프트웨어 - 진화
  + 맞춤 소프트웨어 - 유지보수

##### 폭포수 모델
선형 순차 모델, 재작업을 위해 앞 단계로의 피드백이 불가피
1. 타당성 조사
  + 문제점 파악, 투입 비용 대비 이익을 평가
    + 조직 측면 타당성
    + 경제적 타당성
    + 기술적 타당성
    + 운영의 타당성
2. 요구 분석과 명세
  + 가장 중요한 단계
  + 요구사항 명세서(SRS) : 의뢰자와 개발자 간의 의사소통 수단으로 정확하고 일관성 있으며 완전해야 함
  + 구성 
    + 시스템의 목적과 범위
    + 기능적 / 비기능적 요구사항
    + 기타 제약 조건
3. 설계와 명세
  + *what*을 *how*로 변환하는 작업
  + 아키텍처 설계 - 인터페이스 설계 - 프로그램 설계
4. 코딩과 단위 테스트
  + 설계 결과를 프로그램으로 작성
    + 코드 컨벤션 / 테스트 절차..
5. 통합과 시스템 테스트
  + 통합 테스트 : 모듈들을 통합하여 점증적으로 확인
  + 시스템 테스트 : 모든 모듈 통합 후, 최종적으로 완성된 시스템 확인
  + 알파 테스트 
    + 소프트웨어 개발 현장에서 수행
    + 일반 소프트웨어
      + 알파 테스트 수행 -> 베타 릴리스
    + 주문형 소프트웨어
      + 개발자 플랫폼에서 시뮬레이션, 고객이 만족할때 까지
  + 베타 테스트
    + 사용자 실제 환경에서 테스트
6. 인도와 유지보수
  + 인도 : 배포
  + 유지보수비용이 개발비용보다 많이 책정될 수 있다
  + 유지보수 종류
    + 수정 유지보수 : 오류를 수정하기 위한 것
    + 적응 유지보수 : 변경된 환경에 적응시키기 위한 것
    + 완전 유지보수 : 기능 개선이나 성능의 향상을 위한 것
    + 예방 유지보수 : 유지보수성을 높이기 위한 것

###### 장/단점
+ 장점
  + 선형 모델로 이해하기 쉬움
  + 체계적인 문서화 가능
  + 프로젝트 진행상황 명확하게 알 수 있음
+ 단점
  + 요구사항을 완벽하게 작성
  + 변경 수용의 어려움
  + 시스템의 동작을 후반에 볼 수 있음
  + 대형 프로젝트에 부적합
  + 문서화에 대한 노력이 지나침
  + 위험 분석의 결여, 일정의 지연 가능성

##### 반복진화형 모델
초기 버전을 만들고 요구사항을 정제하여 새로운 버전을 개발하는 작업을 반복하면서 시스템을 완성해 가는 방식    
(불안정한 요구사항) -> 명세 -> 개발 -> 검증 -> (초기버전, 프로토타이핑) -> 명세 ... -> (중간 버전, 프로토타이핑) -> .... -> (중간 버전, 프로토타이핑) -> .... -> (최종버전) -> (유지보수)

###### 장/단점
+ 장점
  + 요구사항이 완전하지 않아도 초기 버전 제작 후 점차적으로 명확한 요구사항 도출
+ 단점
  + 개발 비용의 예상이 힘듬, 재작업이 잦아지면 일정 오바
  + 잦은 수정은 소프트웨어 구조에 악영향 -> 유지보수에 문제

##### 점증적 모델
여러 개의 모듈로 **분해**하고 각각을 점증적으로 개발하여 인도하는 방식    
+ 각 모듈을 증분(increment)이라 함
+ 핵심 모듈을 먼저 개발하고 인도
+ 요구사항 정의 -> 요구사항 증분 배정 -> 시스템 설계 -> 증분 개발 -> 증분 확인 -> 증분 통합 -> 시스템 확인 -> 최종 결과

###### 장/단점
+ 장점
  + 중요한 증분이 먼저 개발, 시스템을 이른 시기에 확인 가능
  + 요구사항 변화에 대응하기 용이
  + 중요 부분이 반복적으로 테스트
+ 단점
  + 애초에 기능을 분해하기 어려울 수 있음
  + 증분을 적당한 크기로 나누기 어려움

##### 점증적 모델 VS 반복진화형 모델
+ 반복진화형 모델은 작업 프로세스를 계속 반복해나가면서 완성
  + 요구사항의 변화를 수용
  + 명확히 이해할 수 없는 새로운 기술을 적용할 때 사용
  + 한꺼번에 모든 기능을 포함해 배포해야하는 경우 사용
+ 점증적 모델은 모듈(증분)으로 분해해서 개발 후 통합하는 방식
  + 중요한 요구사항 먼저 개발
  + 조금씩 개발하면서 여러 번의 릴리스 발생
  
##### 프로토타이핑 방법
소프트웨어 요구사항을 파악하기 위한 좋은 방법
+ 빠른 계획 - 빠른 설계 - 프로토타입 만들기 - 프로토타입 실행과 피드백
+ throwaway prototyping
  + 의사소통용, 한번 쓰고 버림
+ evolutionary prototyping
  + 지속적으로 발전시켜 완제품 완성

###### 장/단점
+ 장점
  + 가능성을 판단 가능
  + 개발자 - 사용자의 의사소통이 명확
  + 기능 이외에도 품질 요구를 분명히 할 수 있음
  + 개발단계에서 유지보수가 일어날 수 있음
+ 단점
  + 문서화가 힘듬, 프로젝트 진행상황을 파악하기 어려움

##### 나선형 모델
반복 진화형 모델의 확장 형태    
전체 생명주기에 위험분석과 프로토타이핑을 계획하고 사용하여 **위험성을 최소화**하기 위한 목적
+ 원이 한바퀴 돌면 다음 프로세스 단계로 넘어감
  + 1 :목표, 대안, 제약 조건 결정
  + 2 :위험 요소 분석, 대안 평가
  + 3 :개발과 확인
  + 4 :다음 단계 계획
+ 위험 관리를 지원하는 프로세스의 프로엠워크
+ 위험관리에 비용이 들지만 가치가 있음
+ 실험적이고 복잡한 대형 프로젝트에 적합

###### 장/단점
+ 장점
  + 당연히 위험성이 낮지요
+ 단점
  + 경험이 부족하여 충분히 검증되지 않음
  + 복잡함
  + 프로젝트 관리의 어려움

##### V 모델
폭포수 모델의 확장 형태, 생명주기 단계별로 상응하는 테스트 단계가 존재     
우하향 하다가 우상향    
테스트 작업을 중요시
사용자 요구 명세서 -> 인수테스트 계획 -> 인수테스트   
  시스템 요구 명세서 -> 시스템 테스트 계획 -> 시스템 테스트    
    시스템 설계 -> 통합 테스트 계획 -> 통합 테스트    
      단위 설계 -> 테스트 케이스 -> 단위 테스트    
        코드

##### 애자일 방법
+ Agile : 날렵한, 민첩한
+ 변화 수용, 협업 강조, 제품의 빠른 배포를 강조하는 반복적 개발 방법
  + 문서화 < 코드
  + 요구사항의 변화는 받아들여라
  + 기존에는 설계에 기간이 길다
  + 환경에 빠른 변화에 대응
+ 요구사항이 바뀌기 쉬운 중소형의 비즈니스 시스템, 전자 상거래 응용에 적합

###### XP, 익스트림 프로그래밍
+ 실천 지침
  + 작고 빈번한 릴리스, 빠른 피드백과 지속적 개선
  + 고객도 개발 팀의 일원이 됨
  + 프로세스 중심이 아닌 사람 중심의 작업 (짝 프로그래밍)
  + 테스트 선행 개발
  + 리팩토링
+ *짝 프로그래밍*
  + 한 놈은 개발 한 놈은 검수를 진행을 30분 마다 바꿔서 진행
    + 책임감 공유
    + 비형식적 검토
    + 리팩터링 장려
    + 생산성의 떨어지지 않음
+ *테스트 선행 개발*
  + 테스트 케이스를 먼저 작성하고 이것을 통과하는 코드를 만들 것
  + 테스트 별로 테스트 케이스를 만듦
    + 요구사항 -> 스토리 카드, 스토리 카드 -> 태스크
  + 통합 테스트 강조, 통합 과정에서 기존 소프트웨어 오류가 유입 되지 않도록 함
    + 기존 테스트 케이스를 재사용하여 오류 유입의 가능성을 줄인다
+ *스크럼*
  + 프로젝트 관리 프레임 워크
  + 계획 + 스프린트
    + 프로젝트 계획 (백로그)
    + 스프린트 사이클
      + 증분을 개발하는 작은 프로젝트
      + 3-9명의 팀에서 한 달 이내로 개발
      + 스프린트 계획(스프린트 백로그)
      + 일일 스크럼 회의
      + 스프린트 리뷰와 회고
  + 스크럼 팀 : 개발 팀 + 제품 책임자 + 스크럼 마스터                 